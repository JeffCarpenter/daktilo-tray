#+title: Daktilo Tray Hacking Guide
#+author: Codex (GPT-5)
#+date: 2025-11-27

* Meta
:PROPERTIES:
:audience: Contributors & release engineers
:last_verified: 2025-11-27
:depends_on: AGENTS.md
:END:
- Read `AGENTS.md` first for repo etiquette; this file focuses on hands-on workflows and automation.
- Keep this guide close to source: update it whenever scripts or automation change.

* Environment Bootstrap
** Toolchain Checklist
- [ ] Rust stable toolchain (`rustup default stable`)
- [ ] `cargo-dist` (`cargo install cargo-dist`)
- [ ] GitHub CLI (`winget install GitHub.cli`) authenticated via `gh auth login`
- [ ] WiX 3.11 binaries on `PATH` (`wix311-binaries.zip` works fine)
- [ ] Windows 10+ SDK (for `signtool.exe`)
- [ ] PowerShell 7+ (`winget install Microsoft.PowerShell`)

** One-liner setup (run inside repo)
#+begin_src powershell
./scripts/release-windows.ps1 -SkipSecrets -Repo yourorg/daktilo-tray -PfxPassword dummy
#+end_src
This command double-checks the presence of all CLI dependencies and fails loudly with install hints.

* Daily Dev Loop
** Build & Run
- `cargo fmt && cargo clippy --all-targets --all-features`
- `cargo run --release` for realistic audio timing
- `cargo check` before committing (captures serde/state regressions quickly)

** Cache + state notes
- Runtime cache: `%LOCALAPPDATA%/daktilo_tray_cache.toml`; delete it when presets or device names drift.
- `State` serialization changes require version notes in PRs (because tray cache and release behavior rely on it).

* Release Automation
** Fast path (full release, cert export + signing + tagging)
#+begin_src powershell
pwsh scripts/release-windows.ps1 \
  -SubjectName "CN=Your Company" \
  -StoreLocation LocalMachine \
  -PfxPassword 'Sup3rS3cret!' \
  -Repo yourorg/daktilo-tray \
  -Tag v0.2.0
#+end_src
Steps performed:
1. Export matching cert from Windows cert store (use `-Thumbprint` for precision)
2. Base64 encode + push `WINDOWS_CODESIGN_*` secrets via `gh secret set`
3. Write `.codesign.env` snapshot for local signing
4. `dist build --allow-dirty --installer msi` (targets from `dist-workspace.toml`)
5. Sign all `.exe`/`.msi`/`.zip` outputs with `scripts/sign-windows.ps1`
6. Create/push git tag if `-Tag` provided

** Reusing secrets for iterative smoke tests
#+begin_src powershell
pwsh scripts/release-windows.ps1 -SkipSecrets -Repo yourorg/daktilo-tray -PfxPassword 'Sup3rS3cret!'
#+end_src
(Uses existing `.codesign.env`, so nothing touches the cert store.)

** Manual knobs
- `scripts/bootstrap-codesign.ps1`: export + secret publication only
- `scripts/prepare-codesign-secrets.ps1`: use when you already have a `.pfx` file on disk
- `scripts/sign-windows.ps1`: sign arbitrary artifacts given base64 + password

** Channel-aware certificates via dist metadata
- `dist-workspace.toml` now owns `[workspace.metadata.dist.codesign]`; add one entry per channel (ex: `dev`, `stable`) with `store`, `store_location`, `subject`/`thumbprint`, and optional `env_file`.
- `scripts/release-windows.ps1 -Channel stable -PfxPassword 'prodsecret' -Repo yourorg/daktilo-tray` will auto-populate the store + selector using that metadata, export the cert, push secrets, and sign. Override any field with explicit CLI flags when needed.
- The helper now probes `SIGNTOOL_PATH`, `PATH`, and the common Windows SDK locations so `signtool.exe` is always found without you having to mutate the environment first.
- Keep the `stable` thumbprint updated to match the publicly trusted cert installed in `LocalMachine\My`. For dev smoke tests pick `Channel dev` so the script defaults to the self-signed cert minted by `scripts/provision-dev-cert.ps1`.

** Dev/test certificate provisioning
- `scripts/provision-dev-cert.ps1 -SubjectName "CN=Daktilo Tray Dev" -PfxPassword 'devonly' -Repo yourorg/daktilo-tray` mints a short-lived self-signed Authenticode cert via `New-SelfSignedCertificate`, exports it, and reuses `prepare-codesign-secrets.ps1` to push secrets + refresh `.codesign.env`.
- Add `-SkipGitHubSecrets` to avoid touching GitHub and only refresh the local env snapshot (useful when you just need local smoke test signatures).
- Reminder: Windows will not trust self-signed dev certs automatically-import them into Trusted Root locally if you need to suppress warnings, but never ship them to end users.

** ACME bootstrap with Caddy + Let's Encrypt
- Use `scripts/request-acme-pfx.ps1 -Domains @("sign.yourdomain.com") -Email you@yourdomain.com -OutputPfx .\public-ca.pfx -PfxPassword 'change-me'` to spin up `caddy run` with an in-memory Caddyfile, satisfy HTTP-01 on this host, wait for the issued certificate under `target/acme-cache/`, and convert it to a PFX automatically.
- Pass `-DnsProvider cloudflare -CloudflareApiToken $env:CLOUDFLARE_API_TOKEN` if you compiled Caddy with the `dns.providers.cloudflare` module and prefer DNS-01 validation through Cloudflare.
- The script only orchestrates issuance + conversion; you still need a CA that can give you a true Authenticode cert (Let's Encrypt only covers TLS). Use the exported PFX to seed staging environments or to prove domain control while you work with a commercial CA.
- Prefer automation? Trigger the manual **Request ACME PFX** workflow in GitHub; it installs Caddy on a Windows runner, invokes the same script with your inputs, injects Cloudflare tokens from secrets, and uploads both the `.pfx` and `.env` snapshot as artifacts for operators.

** Supply-chain gate (cargo-pants)
- CI calls `scripts/run-cargo-pants.ps1`, which parses the BOM emitted by `cargo pants` and fails Windows releases only when a vulnerability meets or exceeds the CVSS threshold declared in `[workspace.metadata.dist.supply_chain]`.
- Add `[workspace.metadata.dist.supply_chain.channels.dev]`, `[...stable]`, etc. when you want per-track policies. The helper accepts `-Channel`, merges the base table with the requested channel, and the release workflow already passes `dev` for PRs and `stable` for signed tags so you never have to edit TOML between runs.
- Threshold defaults to 7.0 (High). Override per run with `pwsh scripts/run-cargo-pants.ps1 -SeverityThreshold 9.0` if you need to allow High vulns temporarily.
- Use `.pants-ignore` to squash already triaged CVEs; the helper respects `--dev` when `include_dev_dependencies = true` in the dist metadata.

** Coverage drill
- Install `cargo-llvm-cov` (`cargo install cargo-llvm-cov --locked`), then run `pwsh scripts/run-coverage.ps1 -HtmlReport` to reset instrumentation, execute the workspace, and emit both `target/coverage/lcov.info` and an HTML dashboard under `target/coverage/html`.
- `.github/workflows/coverage.yml` executes the same helper on every PR + `main` push and uploads the coverage folder as an artifact so reviewers can diff deltas or feed the LCOV file into Codecov/coveralls later.

* Dist + Packaging Notes
- `dist-workspace.toml` is the authoritative source for installers and targets; keep `targets` trimmed to what you can sign.
- After editing dist metadata, run `dist generate` to refresh `.github/workflows/release.yml` and `wix/main.wxs`.
- CI expects WiX + signtool on Windows runners; locally mimic this with `tools/wix311/bin` before invoking `dist build`.

* Troubleshooting
** Signing fails with "signtool.exe not found"
- Confirm Windows SDK `bin` path is on `PATH`; rerun `pwsh scripts/release-windows.ps1 -SkipSecrets ...` after fixing.
** GitHub secrets rejected
- `gh auth status` must show valid scopes; re-auth with `gh auth login`.
** MSI build fails due to outdated workflow
- Run `dist init --yes` (or `dist generate`) and recommit the regenerated files.

* Change Control
- Whenever you touch `scripts/*.ps1` or `dist-workspace.toml`, update this guide and add an entry to `WORK.org`.
- Keep `.codesign.env` out of git (already in `.gitignore`); rotate secrets if it leaks.
