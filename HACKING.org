#+title: Daktilo Tray Hacking Guide
#+author: Codex (GPT-5)
#+date: 2025-11-27

* Meta
:PROPERTIES:
:audience: Contributors & release engineers
:last_verified: 2025-11-27
:depends_on: AGENTS.md
:END:
- Read `AGENTS.md` first for repo etiquette; this file focuses on hands-on workflows and automation.
- Keep this guide close to source: update it whenever scripts or automation change.

* Environment Bootstrap
** Toolchain Checklist
- [ ] Rust stable toolchain (`rustup default stable`)
- [ ] `cargo-dist` (`cargo install cargo-dist`)
- [ ] GitHub CLI (`winget install GitHub.cli`) authenticated via `gh auth login`
- [ ] WiX 3.11 binaries on `PATH` (`wix311-binaries.zip` works fine)
- [ ] Windows 10+ SDK (for `signtool.exe`)
- [ ] PowerShell 7+ (`winget install Microsoft.PowerShell`)

** One-liner setup (run inside repo)
#+begin_src powershell
./scripts/release-windows.ps1 -SkipSecrets -Repo yourorg/daktilo-tray -PfxPassword dummy
#+end_src
This command double-checks the presence of all CLI dependencies and fails loudly with install hints.

* Daily Dev Loop
** Build & Run
- `cargo fmt && cargo clippy --all-targets --all-features`
- `cargo run --release` for realistic audio timing
- `cargo check` before committing (captures serde/state regressions quickly)

** Cache + state notes
- Runtime cache: `%LOCALAPPDATA%/daktilo_tray_cache.toml`; delete it when presets or device names drift.
- `State` serialization changes require version notes in PRs (because tray cache and release behavior rely on it).

* Release Automation
** Fast path (full release, cert export + signing + tagging)
#+begin_src powershell
pwsh scripts/release-windows.ps1 \
  -SubjectName "CN=Your Company" \
  -StoreLocation LocalMachine \
  -PfxPassword 'Sup3rS3cret!' \
  -Repo yourorg/daktilo-tray \
  -Tag v0.2.0
#+end_src
Steps performed:
1. Export matching cert from Windows cert store (use `-Thumbprint` for precision)
2. Base64 encode + push `WINDOWS_CODESIGN_*` secrets via `gh secret set`
3. Write `.codesign.env` snapshot for local signing
4. `dist build --installer msi` (pass `-AllowDirty` if you truly need to bypass the cleanliness guard)
5. Sign all `.exe`/`.msi`/`.zip` outputs with `scripts/sign-windows.ps1`
6. Create/push git tag if `-Tag` provided

** Reusing secrets for iterative smoke tests
#+begin_src powershell
pwsh scripts/release-windows.ps1 -SkipSecrets -Repo yourorg/daktilo-tray -PfxPassword 'Sup3rS3cret!'
#+end_src
(Uses existing `.codesign.env`, so nothing touches the cert store.)

** Manual knobs
- `scripts/bootstrap-codesign.ps1`: export + secret publication only
- `scripts/prepare-codesign-secrets.ps1`: use when you already have a `.pfx` file on disk
- `scripts/sign-windows.ps1`: sign arbitrary artifacts given base64 + password
- `scripts/release-windows.ps1` now enforces a clean git tree before invoking `dist build`; pass `-AllowDirty` only for local smoke tests when you intentionally have pending edits.
- Want to refresh `.codesign*.env` locally without touching GitHub secrets? Run `scripts/release-windows.ps1 -SkipGitHubSecrets` (or call `bootstrap-codesign.ps1` with the same switch); it still exports the cert + writes the env snapshot but skips the `gh secret set` calls.

** Channel-aware certificates via dist metadata
- `dist-workspace.toml` now owns `[workspace.metadata.dist.codesign]`; add one entry per channel (ex: `dev`, `stable`) with `store`, `store_location`, `subject`/`thumbprint`, and optional `env_file`.
- `scripts/release-windows.ps1 -Channel stable -PfxPassword 'prodsecret' -Repo yourorg/daktilo-tray` will auto-populate the store + selector using that metadata, export the cert, push secrets, and sign. Override any field with explicit CLI flags when needed.
- The helper now probes `SIGNTOOL_PATH`, `PATH`, and the common Windows SDK locations so `signtool.exe` is always found without you having to mutate the environment first.
- Keep the `stable` thumbprint updated to match the publicly trusted cert installed in `LocalMachine\My`. For dev smoke tests pick `Channel dev` so the script defaults to the self-signed cert minted by `scripts/provision-dev-cert.ps1`.
- Declare each channel's GitHub target up front (`repo = "owner/daktilo-tray"` and `environment = "codesign-prod"`). `scripts/release-windows.ps1` now hydrates `-Repo`, `-EnvFile`, and the environment passed to `gh secret set` automatically from that metadata unless you override them on the CLI.

** Dev/test certificate provisioning
- `scripts/provision-dev-cert.ps1 -SubjectName "CN=Daktilo Tray Dev" -PfxPassword 'devonly' -Repo yourorg/daktilo-tray` mints a short-lived self-signed Authenticode cert via `New-SelfSignedCertificate`, exports it, and reuses `prepare-codesign-secrets.ps1` to push secrets + refresh `.codesign.env`.
- Add `-SkipGitHubSecrets` to avoid touching GitHub and only refresh the local env snapshot (useful when you just need local smoke test signatures).
- Reminder: Windows will not trust self-signed dev certs automatically-import them into Trusted Root locally if you need to suppress warnings, but never ship them to end users.
- `[workspace.metadata.dist.codesign.channels.<name>.auto_provision]` lets you turn on zero-touch certificate synthesis per channel (dev already sets `enabled = true`, plus default validity/hash/key length). When enabled (or when you pass `-AutoProvision`), `scripts/release-windows.ps1` auto-creates a self-signed cert in the configured store if the requested `-SubjectName` is missing before exporting secrets. Disable it with `-AutoProvision:$false` if you only trust manually imported certs, or override knobs per run via `-AutoProvisionValidDays`, `-AutoProvisionKeyLength`, and `-AutoProvisionHashAlgorithm`.

** Installer smoke tests
- `scripts/test-installer.ps1 -ArtifactsDir <dir>` snapshots the latest MSI, installs it quietly, launches the installed binary with `DAKTILO_AUTOSTART_ONLY=1` (which forces the tray app to apply `[workspace.metadata.dist.autostart.default_enabled]` and exit), captures the HKCU `Run` value, runs `signtool verify /pa /v`, uninstalls, and writes every log under `target/smoke-tests/`.
- `.github/workflows/release.yml` has an `installer-smoke` job wired after the Windows build matrix; `host` refuses to publish if the MSI install, autostart check, or signtool verification fails. Grab the `installer-smoke-<run-id>` artifact for the registry snapshot + logs.
- When you need to reproduce this locally, set `DAKTILO_AUTOSTART_ONLY=1` and launch the installed exe once-the app will flip the Run key and exit immediately, so you can inspect the registry without touching the tray/UI.
- Smoke harness emits `target/smoke-tests/signtool-report.json`; schema highlights:
  - `channel`: resolved dist channel (`dev`, `stable`, etc.).
  - `expected`: codesign metadata (subject, thumbprint, store, store_location).
  - `actual`: `file_path`, `subject`, `thumbprint`, `verified`, `signature_status`.
  - `verify`: `command`, `started_at`/`completed_at` (ISO 8601), `duration_seconds`, `exit_code`, and `log_path`.
- `.github/workflows/release.yml` parses the report, prints the structured summary into `$GITHUB_STEP_SUMMARY`, and fails the job when verification mismatches arise. Use the log path if you need to replay signtool locally.

** ACME bootstrap with Caddy + Let's Encrypt
- Use `scripts/request-acme-pfx.ps1 -Domains @("sign.yourdomain.com") -Email you@yourdomain.com -OutputPfx .\public-ca.pfx -PfxPassword 'change-me'` to spin up `caddy run` with an in-memory Caddyfile, satisfy HTTP-01 on this host, wait for the issued certificate under `target/acme-cache/`, and convert it to a PFX automatically.
- Pass `-DnsProvider cloudflare -CloudflareApiToken $env:CLOUDFLARE_API_TOKEN` if you compiled Caddy with the `dns.providers.cloudflare` module and prefer DNS-01 validation through Cloudflare.
- The script only orchestrates issuance + conversion; you still need a CA that can give you a true Authenticode cert (Let's Encrypt only covers TLS). Use the exported PFX to seed staging environments or to prove domain control while you work with a commercial CA.
- Prefer automation? Trigger the manual **Request ACME PFX** workflow in GitHub; it installs Caddy on a Windows runner, invokes the same script with your inputs, injects Cloudflare tokens from secrets, and uploads both the `.pfx` and `.env` snapshot as artifacts for operators.
- That workflow now requires an `environment_name` (default `codesign-prod`). The run is bound to that GitHub environment (so approvals apply) and, after minting the PFX, it runs `gh secret set --env <name>` for `WINDOWS_CODESIGN_PFX`/`WINDOWS_CODESIGN_PASSWORD` so the release wizard can immediately reuse the freshly issued cert bundle.
- Channels can now set `[workspace.metadata.dist.codesign.channels.<name>.auto_provision]` to `mode = "acme"` with an `acme_profile` pointer. Define the profile under `[workspace.metadata.dist.acme_profiles.<profile>]` (domains, contact email, `dns_provider`, `cloudflare_token_env`, optional `state_dir`/`acme_server`/`use_staging`, etc.). When `scripts/release-windows.ps1` resolves such a channel it calls `request-acme-pfx.ps1`, writes the issued `.pfx` into `target/acme-outputs`, imports it into the configured cert store (unless `import_to_store = false`), and immediately feeds it through `prepare-codesign-secrets.ps1` so the channel's `env_file` and GitHub secrets stay in sync. Make sure the channel `subject` matches the primary ACME domain (Let's Encrypt subjects are the FQDN), export the Cloudflare token env var (default `CLOUDFLARE_DNS_API_TOKEN`) before running the script, and launch PowerShell as Administrator if the metadata targets `LocalMachine`.

** Supply-chain gate (cargo-pants)
- CI calls `scripts/run-cargo-pants.ps1`, which parses the BOM emitted by `cargo pants` and fails Windows releases only when a vulnerability meets or exceeds the CVSS threshold declared in `[workspace.metadata.dist.supply_chain]`.
- Add `[workspace.metadata.dist.supply_chain.channels.dev]`, `[...stable]`, etc. when you want per-track policies. The helper accepts `-Channel`, merges the base table with the requested channel, and the release workflow already passes `dev` for PRs and `stable` for signed tags so you never have to edit TOML between runs.
- Threshold defaults to 7.0 (High). Override per run with `pwsh scripts/run-cargo-pants.ps1 -SeverityThreshold 9.0` if you need to allow High vulns temporarily.
- Use `.pants-ignore` to squash already triaged CVEs; the helper respects `--dev` when `include_dev_dependencies = true` in the dist metadata.

** Coverage drill
- Install `cargo-llvm-cov` and `cargo2junit` (`cargo install cargo-llvm-cov --locked && cargo install cargo2junit --locked`), then run `pwsh scripts/run-coverage.ps1 -HtmlReport -GenerateJUnit -AppendToStepSummary` to clean instrumentation, execute the workspace, and emit the LCOV/HTML/JUnit/exit-code bundle under `target/coverage` and `target/test-results`.
- Pass `-EnforceBaseline` locally to mirror CI behavior; the helper reads `[workspace.metadata.dist.coverage.baseline]`, applies the optional `tolerance`, and fails when coverage dips below the stored floor. Update the baseline (and tolerance) inside `dist-workspace.toml` whenever you intentionally raise expectations.
- `.github/workflows/coverage.yml` calls the same helper on `windows-latest`, feeds the generated JUnit file into `dorny/test-reporter@v2` for PR annotations, appends the Markdown summary to `$GITHUB_STEP_SUMMARY`, mouths the LCOV into Codecov (`CODECOV_TOKEN` secret required for private forks), and uploads the combined artifact so you can drill into LCOV/HTML/JUnit locally.
- Main-branch pushes also upload `target/coverage/html` via `actions/upload-pages-artifact`; the follow-on `publish-coverage` job deploys it to the `coverage-site` GitHub Pages environment so you can browse hit/miss diffs without downloading artifacts. Grab the URL from the deployment badge or the job summary.
- Pull requests receive a refreshed coverage/test comment (look for `<!-- daktilo-coverage-report -->`) sourced from `target/coverage/comment.md`. Update `[workspace.metadata.dist.coverage.pages_url]` if the published HTML lives somewhere else so the comment link stays accurate.
- Keep the summary lean so it stays under GitHub's 1 MiB per-step limit, and rotate the baseline whenever we add meaningful tests so the enforcement step remains signalful.

* Dist + Packaging Notes
- `dist-workspace.toml` is the authoritative source for installers and targets; keep `targets` trimmed to what you can sign.
- After editing dist metadata, run `dist generate` to refresh `.github/workflows/release.yml` and `wix/main.wxs`.
- CI expects WiX + signtool on Windows runners; locally mimic this with `tools/wix311/bin` before invoking `dist build`.

* Troubleshooting
** Signing fails with "signtool.exe not found"
- Confirm Windows SDK `bin` path is on `PATH`; rerun `pwsh scripts/release-windows.ps1 -SkipSecrets ...` after fixing.
** GitHub secrets rejected
- `gh auth status` must show valid scopes; re-auth with `gh auth login`.
** MSI build fails due to outdated workflow
- Run `dist init --yes` (or `dist generate`) and recommit the regenerated files.

* Change Control
- Whenever you touch `scripts/*.ps1` or `dist-workspace.toml`, update this guide and add an entry to `WORK.org`.
- Keep `.codesign.env` out of git (already in `.gitignore`); rotate secrets if it leaks.



