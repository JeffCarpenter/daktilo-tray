#+title: Daktilo Tray WORKLOG
#+author: Codex (GPT-5)
#+date: 2025-11-27

* Metadata
:PROPERTIES:
:repo: daktilo-tray
:goal: Add run-on-login/startup toggle driven by release metadata.
:constraints: Must use cargo-dist config, auto launch should be user friendly, log progress here.
:END:

* Research Notes
** Auto-launch RTFM
- auto-launch 0.5.0 gives cross-platform registry/LaunchAgent helpers; Windows implementation writes HKCU Run; API surface: `AutoLaunchBuilder::new().set_app_name().set_app_path().set_args().build()` plus `enable/disable/is_enabled`.
- We'll reuse `auto_launch::AutoLaunch::is_support()` to guard menu visibility; errors bubble via crate's `Error` enum.
** cargo-dist knobs
- `cargo-dist` consumes `[workspace.metadata.dist]` either inside `Cargo.toml` or `dist-workspace.toml`; we can extend that table with nested `[workspace.metadata.dist.autostart]` describing defaults without breaking dist tooling.
- We'll read that TOML during build/runtime (via `include_str!`) to feed default autostart preference + prompt copy so release metadata is the single source of truth.

** Cryptography Ecosystem (AWWY 2025-11-27)
:PROPERTIES:
:source: https://arewewebyet.org/topics/cryptography/
:retrieved: 2025-11-27T14:20:00-06:00
:END:
- Rust already ships production-ready libs for most primitives: libsodium bindings, high-level libs such as `ring`, TLS stacks (`rustls`) and entire suites curated by RustCrypto; the ecosystem status board flags these as “usable now,” so we can lean on them for any secret management we add to the tray tooling.
- Web stack coverage calls out the same crates we rely on indirectly (RustCrypto hashing/AEAD crates) which lowers risk when we bump dependencies to keep Windows signing metadata tamper-proof.

** RustCrypto Snapshot (GitHub 2025-11-27)
:PROPERTIES:
:source: https://github.com/RustCrypto
:retrieved: 2025-11-27T14:25:00-06:00
:END:
- Key repos remain extremely active: `RustCrypto/hashes` (2.1k★, 30 open issues) and `RustCrypto/block-ciphers` (742★) both updated today, so pinning to their latest releases is viable.
- `RustCrypto/AEADs` (873★) and `RustCrypto/elliptic-curves` (813★) give us high-level primitives if we ever need signing for updater metadata.
- Password/KDF coverage via `RustCrypto/password-hashes` (826★) means we can store any optional signing passwords using battle-tested libs instead of rolling our own.

** cargo-pants Docs
:PROPERTIES:
:source: https://github.com/sonatype-nexus-community/cargo-pants
:retrieved: 2025-11-27T14:28:00-06:00
:END:
- `cargo-pants` is a `cargo` subcommand that parses `Cargo.lock`, emits a BOM, and queries Sonatype OSS Index for vulnerabilities; exits with code 3 when findings exist.
- Supports `.pants-ignore` for squelching known CVEs, verbose/loud flags for BOM dumps, and optional Nexus IQ integration via `cargo iq`.
- Requires Rust 1.49+ and `OSS_INDEX_API_KEY`; we can integrate it into CI as a targeted supply-chain gate if we want hardened release pipelines before signing.

** Windows Distribution Enhancements
:PROPERTIES:
:goal: Automate cert lifecycle + cargo-dist signing
:status: in-progress
:END:
- Extend automation with `scripts/provision-dev-cert.ps1` so dev builds can auto-mint a self-signed Authenticode cert, export a PFX, and reuse our secret/sealed env path with zero manual steps.
- Future improvements: add Store/Thumbprint metadata to `dist-workspace.toml` so `release-windows.ps1` can auto-select the right cert per channel; keep secrets isolated per CI environment by pointing `prepare-codesign-secrets.ps1` at repo-specific GH scopes.
- Let's Encrypt cannot issue Authenticode certs, so we still need a commercial CA for production; we can nevertheless reuse Caddy-managed ACME flows to run a private CA for nightly testing and feed those certs into the same script pipeline.

** ACME via Caddy
:PROPERTIES:
:source: https://caddyserver.com/docs/command-line
:retrieved: 2025-11-27T15:05:00-06:00
:END:
- `caddy run --config <file> --adapter caddyfile` honors the global `email`, `acme_ca`, and `storage` options, so we can drive Let's Encrypt issuance by writing a tiny temporary Caddyfile per domain.
- Site blocks with `respond` + `tls { dns cloudflare { token {env.CLOUDFLARE_API_TOKEN} } }` hook into the Cloudflare DNS challenge as long as the binary is built with the Cloudflare provider.
- Certificates land under `<storage>/certificates/<acme-host>-directory/<domain>/<domain>.crt|.key`, so converting them into a Windows-friendly PFX is just a matter of feeding those PEMs into .NET's `X509Certificate2.CreateFromPemFile`.

* Plan
** Milestones
1. Document plan + default values from dist config (this section, `WORK.org`).
2. Implement runtime autostart manager + tray menu toggle; persist state.
3. Wire release metadata + README/docs so cargo-dist builds know about the feature.
** Task Breakdown
- [X] Parse `dist-workspace.toml` for `[workspace.metadata.dist.autostart]` defaults (fallback to safe values if missing).
- [X] Create `AutostartController` abstraction using `auto-launch` (only instantiate on supported OS) that exposes `current()` and `set(bool)`.
- [X] Extend cached `State` with `run_on_login` and serialize.
- [X] Add tray checkbox + event handling that syncs UI, `State`, controller errors, and logs.
- [X] Persist updated state on exit along with new field.
- [X] Update Cargo manifest (dependencies + metadata) and add `dist-workspace.toml` capturing release knobs + human-friendly copy.
- [X] Document feature in README (usage + how to set default via dist config) and recap changes here once done.

* Log
** 2025-11-27T10:15:00-06:00 Kickoff
- Captured requirements + doc pointers; plan ready.
** 2025-11-27T11:05:00-06:00 Implementation
- Added auto-launch integration, state persistence, and tray toggle; default wiring reads from dist-workspace.toml.
- Created dist-workspace metadata + README instructions; ran `cargo fmt` + `cargo check` (warnings only from upstream). 
** 2025-11-27T12:00:00-06:00 Signing
- Enabled SSL.com-backed signing via `ssldotcom-windows-sign = "prod"`, refreshed dist artifacts, and documented required GitHub secrets + local signtool workflow.
- Regenerated release CI, provisioned WiX locally, and ran `dist build --installer msi` to validate the pipeline end-to-end.
** 2025-11-27T12:40:00-06:00 Signtool Migration
- Replaced SSL.com integration with a local `signtool` workflow (scripts/sign-windows.ps1) and documented the new `WINDOWS_CODESIGN_*` secrets plus local testing steps.
** 2025-11-27T13:00:00-06:00 Secret Automation
- Added scripts/prepare-codesign-secrets.ps1 plus README/.gitignore updates so `gh` can ingest the PFX + password and stash a local .codesign.env for deterministic signing runs.
** 2025-11-27T13:20:00-06:00 Release Wizard
- Added scripts/release-windows.ps1 so a single command exports the cert, uploads secrets, runs cargo-dist, signs artifacts, and optionally tags the repo; README now documents the exact invocation.
** 2025-11-27T13:35:00-06:00 Hacking Doc
- Authored HACKING.org (env bootstrap, release wizard usage) and linked it from AGENTS.md.
** 2025-11-27T14:35:00-06:00 Crypto Research + Dev Cert Automation
- Reviewed AreWeWebYet cryptography status + RustCrypto repos to confirm we can lean on curated crates for any signing/secrets work.
- Documented `cargo-pants` usage for BOM + vulnerability scanning so we can wire it into the Windows release CI before signing.
- Added `scripts/provision-dev-cert.ps1`, taught `prepare-codesign-secrets.ps1` how to skip GH publishing, and documented the optional dev-cert flow in README + HACKING.
** 2025-11-27T15:45:00-06:00 Supply-chain + CA automation
- Created `scripts/common-dist.ps1` so PowerShell automation can read `dist-workspace.toml` once and share channel defaults.
- Added per-channel codesign metadata + supply-chain thresholds to `dist-workspace.toml`; `scripts/release-windows.ps1` now accepts `-Channel` and auto-populates store/selector/env-file.
- Authored `scripts/run-cargo-pants.ps1` and wired it into `.github/workflows/release.yml` (Windows runners install `cargo-pants`, run the helper, and only fail the job when the configured CVSS threshold is crossed).
- Wrote `scripts/request-acme-pfx.ps1` to spin up Caddy, satisfy HTTP/DNS challenges, and convert the resulting PEMs into a PFX for downstream signing flows.
- Updated `HACKING.org`, `README.md`, and `.gitignore` with the new workflows plus documented everything here per AGENTS.md.
** 2025-11-27T17:45:00-06:00 Channel rehearsal + release wizard polish
- Expanded `[workspace.metadata.dist.supply_chain]` with channel-specific overrides (`dev` includes dev-deps @ 8.5 CVSS, `stable` sticks to 7.0) and taught `scripts/run-cargo-pants.ps1` to accept `-Channel` so CI no longer needs manual threshold tweaks.
- Hardened signtool detection with `Get-SignToolPath` (checks `SIGNTOOL_PATH`, PATH, and Windows SDK installs) and plumbed it through `scripts/release-windows.ps1`/`scripts/sign-windows.ps1`; filtered signing to skip `target\dist\build\*.exe` so signing no longer takes 10+ minutes.
- Rehearsed `scripts/release-windows.ps1 -Channel dev` and `-Channel stable` end-to-end with the locally minted dev cert + `.codesign.*.env` snapshots (`dist build --installer msi` succeeded twice, artifacts signed with the self-signed cert, warnings limited to upstream `daktilo_lib` docs/cfg hints).

** 2025-11-27T18:20:00-06:00 ACME workflow + docs
- Authored `.github/workflows/acme-pfx.yml` so operators can manual-dispatch a Windows runner that installs Caddy, calls `scripts/request-acme-pfx.ps1`, handles Cloudflare DNS tokens automatically, and uploads both the `.pfx` and ready-to-import `.env` snapshot as artifacts.
- Documented the new workflow alongside the existing PowerShell helper in `README.md` and `HACKING.org`; reiterated that Let's Encrypt certs are TLS-only and serve as domain-control proof for commercial Authenticode issuers.

** 2025-11-27T18:45:00-06:00 Coverage automation
- Introduced `scripts/run-coverage.ps1` (wraps `cargo llvm-cov`, emits LCOV + optional HTML, fails fast if prerequisites or outputs are missing) and wired it into `.github/workflows/coverage.yml` on `windows-latest` (installs llvm-tools + cargo-llvm-cov, uploads `target/coverage` artifacts).
- Added contributor guidance + README notes describing how to run the helper locally and interpret the uploaded LCOV bundle; the coverage workflow now runs on every PR + `main` push so regressions are visible before signing artifacts.

* Forward Plan
:PROPERTIES:
:owner: Codex
:last_reviewed: 2025-11-27T18:45:00-06:00
:intent: Hardening + coverage
:END:
** Automation Worklist
:PROPERTIES:
:status: queued
:confidence: high
:END:
- ?? *Secret routing*: teach `scripts/release-windows.ps1` to read its `-Repo`/`-EnvFile` target from `[workspace.metadata.dist.codesign.channels.*]` so channel metadata drives the entire `gh secret set` story.
- ?? *Installer smoke tests*: add a Windows CI job that installs the freshly signed MSI, confirms the autostart registry entries honor channel defaults, and captures `signtool verify` output for each artifact.
- ?? *ACME workflow hardening*: wrap `acme-pfx.yml` in a protected GitHub environment with approvals and auto-promote the emitted `.env` snapshot into environment secrets for the release wizard.
** Coverage Roadmap
:PROPERTIES:
:status: planning
:tools: cargo-llvm-cov, grcov
:END:
- ?? *Codecov uplink*: feed `target/coverage/lcov.info` into Codecov (or equivalent) once tokens land so reviewers see deltas inline.
- ?? *Budget enforcement*: snapshot the current coverage % and fail the coverage job if new commits dip below the agreed floor (allow per-channel overrides if needed).
- ?? *HTML publishing*: surface the generated coverage HTML via Pages or PR comments so contributors can inspect hit/miss heatmaps without downloading artifacts.
