name: Request ACME PFX

on:
  workflow_dispatch:
    inputs:
      domains:
        description: "Comma-separated domain list (e.g. sign.example.com,www.example.com)"
        required: true
        type: string
      email:
        description: "ACME account e-mail"
        required: true
        type: string
      use_staging:
        description: "Use Let's Encrypt staging directory"
        required: false
        default: true
        type: boolean
      dns_provider:
        description: "Optional DNS provider (set to cloudflare to use DNS-01)"
        required: false
        type: string
      environment_name:
        description: "GitHub environment that should receive WINDOWS_CODESIGN_* secrets"
        required: false
        default: "codesign-prod"
        type: string
jobs:
  request:
    name: Mint certificate
    runs-on: windows-latest
    permissions:
      contents: read
      secrets: write
    environment:
      name: ${{ inputs.environment_name }}
    env:
      CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - uses: actions/checkout@v4
      - name: Install Caddy
        shell: pwsh
        run: |
          choco install caddy --no-progress -y
      - name: Request certificate with scripts/request-acme-pfx.ps1
        id: request
        shell: pwsh
        run: |
          $domainList = "${{ inputs.domains }}".Split(',') | ForEach-Object { $_.Trim() } | Where-Object { $_ }
          if (-not $domainList) {
            throw "Provide at least one domain"
          }
          $artifactDir = Join-Path $PWD "acme-artifacts"
          New-Item -ItemType Directory -Path $artifactDir -Force | Out-Null
          $timestamp = Get-Date -Format "yyyyMMddHHmmss"
          $outputPfx = Join-Path $artifactDir "daktilo-$timestamp.pfx"
          $pfxPassword = [guid]::NewGuid().ToString("N")
          $scriptArgs = @{
            Domains    = $domainList
            Email      = "${{ inputs.email }}"
            OutputPfx  = $outputPfx
            PfxPassword = $pfxPassword
            StateDir   = "target/acme-cache"
          }
          if ("${{ inputs.use_staging }}" -eq "true") {
            $scriptArgs.UseStaging = $true
          }
          if ($env:CLOUDFLARE_API_TOKEN) {
            $env:CLOUDFLARE_API_TOKEN = $env:CLOUDFLARE_API_TOKEN.Trim()
          }
          if ("${{ inputs.dns_provider }}") {
            $scriptArgs.DnsProvider = "${{ inputs.dns_provider }}"
            if ("${{ inputs.dns_provider }}" -ieq "cloudflare") {
              if (-not $env:CLOUDFLARE_API_TOKEN) {
                throw "CLOUDFLARE_API_TOKEN secret required for Cloudflare DNS validation"
              }
              $scriptArgs.CloudflareApiToken = $env:CLOUDFLARE_API_TOKEN
            }
          }
          ./scripts/request-acme-pfx.ps1 @scriptArgs
          $base64 = [Convert]::ToBase64String([System.IO.File]::ReadAllBytes($outputPfx))
          $envFile = Join-Path $artifactDir "daktilo-$timestamp.env"
          @(
            "WINDOWS_CODESIGN_PFX=$base64",
            "WINDOWS_CODESIGN_PASSWORD=$pfxPassword"
          ) | Set-Content -Encoding UTF8 -Path $envFile
          "pfx-path=$outputPfx" >> $Env:GITHUB_OUTPUT
          "env-path=$envFile" >> $Env:GITHUB_OUTPUT
          $targetEnv = "${{ inputs.environment_name }}"
          if ($targetEnv) {
            $repo = "${{ github.repository }}"
            Write-Host "Publishing WINDOWS_CODESIGN_* secrets to $repo (env: $targetEnv)"
            gh secret set WINDOWS_CODESIGN_PFX --repo $repo --env $targetEnv --body $base64
            gh secret set WINDOWS_CODESIGN_PASSWORD --repo $repo --env $targetEnv --body $pfxPassword
          }
      - name: Upload requested cert bundle
        uses: actions/upload-artifact@v4
        with:
          name: acme-pfx-${{ github.run_id }}
          path: acme-artifacts
          retention-days: 7
